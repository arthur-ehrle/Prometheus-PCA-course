Not rendering RawBlock (Format "tex") "\\documentclass[10pt,letterpaper]{article}\n\n\n\\usepackage{graphicx}\n\\usepackage{enumitem} \n\\usepackage{float}\n\\usepackage[letterpaper,margin=0.75in]{geometry}\n\\usepackage[utf8]{inputenc}\n\\usepackage[T1]{fontenc}\n\\usepackage[french]{babel}\n\\usepackage{graphicx}\n\\usepackage{float}\n\\usepackage{xcolor}\n\\usepackage{fancyhdr}\n\\usepackage{amsmath}\n\\usepackage{lastpage}\n\\usepackage{url}\n\\usepackage{array}\n\\pagestyle{fancy}\n\\renewcommand\\headrulewidth{1pt}\n\\fancyhead[L]{ \\quad OnCloud }\n\\fancyhead[R]{Arthur Ehrl\233}\n\\fancyfoot[L]{\\quad Prometheus Certified Associate (PCA)}\n\\renewcommand\\footrulewidth{1pt}\n\\fancyfoot[C]{\n\\textbf{Page \\thepage/\\pageref{LastPage}}}\n\\fancyfoot[R]{\\today}\n\\author{Arthur Ehrl\233}\n%titre\n\\title{\\textbf{Prometheus - PCA}}\n\\date\\today\n\n\n\\makeatletter\n\\begin{document}\n\\begin{titlepage}\n\\newcommand{\\HRule}{\\rule{\\linewidth}{0.5mm}}\n\\center\n\\textsc{\\LARGE\nT\233l\233com SudParis\n} \\\\[1cm]\n\\begin{center}\n\\includegraphics[scale=0.4]{logo.jpg}\n\\end{center}\n\\rule{\\linewidth}{0.5mm}\\\\[0.4cm]\n%titre page de garde\n{ \\huge \\bfseries \\@title \\\\[0.15cm] } %\\@title\n\\rule{\\linewidth}{0.5mm}\\\\[1.5cm]\n\\@author\n\\\\[1cm]\n\\today \\\\ [1cm]\n\\begin{center}\n\\includegraphics[scale=0.15]{prom.jpg}\n\\end{center}\n\\end{titlepage}\n\\tableofcontents\n\\addtocontents{toc}{~\\hfill\\textbf{Page}\\par}\n\\maketitle{}\n\\thispagestyle{fancy}\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n\n\\section{Observability concepts}\n\\subsection{Metrics}\nIn layperson terms, metrics are numeric measurements. Time series means that changes are recorded over time. What users want to measure differs from application to application. For a web server it might be request times, for a database it might be number of active connections or number of active queries etc.\\\\\nMetrics play an important role in understanding why your application is working in a certain way. Let's assume you are running a web application and find that the application is slow. You will need some information to find out what is happening with your application. For example the application can become slow when the number of requests are high. If you have the request count metric you can spot the reason and increase the number of servers to handle the load.\n\\url{https://prometheus.io/docs/introduction/overview/}\n\\subsection{Understand logs and events}\nAn event is a conceptual abstraction and a structured log is one possible representation of that abstraction. The interesting part of the conversation is where to draw the lines around that abstraction; the technical implementation part is how to represent that event.\n\\subsection{Tracing and Spans}\n\\begin{center}\n\\includegraphics[scale=0.5]{traces.jpg}\n\\end{center}\nA trace is a collection of operations that represents a unique transaction handled by an application and its constituent services. A span represents a single operation within a trace.\\\\A trace is the complete processing of a request. The trace represents the whole journey of a request as it moves through all of the services of a distributed system.\\\\Trace is often visualized using a hierarchical bar chart. Similarly to how Gantt charts represent subtask dependencies and durations in a project, a distributed trace represents dependencies and duration of different microservices processing the request.\\\\\n\\begin{center}\n\\includegraphics[scale=0.5]{span.jpg}\n\\end{center}\n\\begin{itemize}\n\\item Trace exposes the execution path through a distributed system. Trace is composed of one or more spans.\n\\item Span in the trace represents one microservice in the execution path. For instance, a credit score check could be a span in a trace of a loan application processing. Spans can create multiple child spans, and every child span has exactly one parent span.\n\\end{itemize}\n\\subsection{Push vs Pull}\n\\subsubsection{Pull}\nFor the pull approach, the monitoring targets will not send anything to the monitoring server. The server will ``ask'' the targets for the metrics. For example Prometheus as a pull approach and is requesting the targets with http.\n\\subsubsection{Push}\nThe pull approcah consists of making the target sending their metrics to the monitoring server. In the Prometheus case, if a target doesn't support pull but only push, we can use the ``pushgateway'' as an intermediate.\n\\subsection{Service Discovery}\nIn the Prometheus architecture, service discovery (SD) consists as a best practice to improve the scalability/maintainability of the infrastructure. Define your jobs in the prometheus config file and your instances list for SD in exeternal files. The advantages of defining instances in a separate file is that you can add once while prometheus is running without the need of reload the config file.\n\\subsection{Basics of SLOs, SLAs, and SLIs}\n\\begin{center}\n\\includegraphics[scale=0.3]{sla.jpg}\n\\end{center}\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n\\section{Prometheus fundamentals}\n\\subsection{System Architecture}\n\\begin{center}\n\\includegraphics[scale=0.5]{prom_archi.jpg}\n\\end{center}\nThe Prometheus ecosystem consists of multiple components, many of which are optional:\n\\begin{itemize}\n\\item the main Prometheus server which scrapes and stores time series data\n\\item client libraries for instrumenting application code\n\\item a push gateway for supporting short-lived jobs\n\\item special-purpose exporters for services like HAProxy, StatsD, Graphite, etc\n\\item an alertmanager to handle alerts\n\\item various support tools\n\\end{itemize}\nMost Prometheus components are written in Go, making them easy to build and deploy as static binaries.\n\\subsection{Configuration and Scraping}\nConfig file written in yaml so quite easy to read and understand. After the ``global'' key you will find based features like : \n\\begin{itemize}\n\\item scrape\\_interval: periode that will use Prometheus for scraping the targets (1mn by default)\n\\item evaluation\\_interval: periode that will use Prometheus to check the rule file for the alerting part\n\\item scrape\\_timeout: periode that will use Prometheus to determine if a target is unreachable\n\\item rule\\_files: path of the file were we defined the rules for the triggers\n\\item alerting: the url and the port to send PUSH request to alertmanager that will send notifications\n\\item scrape\\_configs: the configuration of the jobs and the instances\n\\end{itemize}\n\\begin{center}\n\\includegraphics[scale=0.8]{scrape_ex.jpg}\n\\end{center}\n\\subsection{Understanding Prometheus Limitations}\nPrometheus values reliability. You can always view what statistics are available about your system, even under failure conditions. If you need 100\\% accuracy, such as for per-request billing, Prometheus is not a good choice as the collected data will likely not be detailed and complete enough. In such a case you would be best off using some other system to collect and analyze the data for billing, and Prometheus for the rest of your monitoring.\\\\In addition, Prometheus can't store logs, you will need te use some others tools like Promtail + Loki.\n\\subsection{Data Model and Labels}\n\\subsubsection{Data model}\nPrometheus fundamentally stores all data as time series: streams of timestamped values belonging to the same metric and the same set of labeled dimensions. Besides stored time series, Prometheus may generate temporary derived time series as the result of queries.\\\\ Prometheus is storing the data with a ``key:value'' reference. Here it's a timestamp (with a millisecond precision) associated with a value. \\\\ \\url{https://prometheus.io/docs/concepts/data_model/}\n\\subsubsection{Labels}\nEvery time series is uniquely identified by its metric name and optional key-value pairs called labels.\\\\\nThe metric name specifies the general feature of a system that is measured (e.g. http \\_requests\\_total - the total number of HTTP requests received). It may contain ASCII letters and digits, as well as underscores and colons. It must match the regex [a-zA-Z\\_:][a-zA-Z0-9\\_:]*.\\\\\nLabels enable Prometheus's dimensional data model: any given combination of labels for the same metric name identifies a particular dimensional instantiation of that metric (for example: all HTTP requests that used the method POST to the /api/tracks handler). The query language allows filtering and aggregation based on these dimensions. Changing any label value, including adding or removing a label, will create a new time series.\\\\\nLabel names may contain ASCII letters, numbers, as well as underscores. They must match the regex [a-zA-Z\\_][a-zA-Z0-9\\_]*. Label names beginning with \\_\\_ are reserved for internal use.\\\\\nLabel values may contain any Unicode characters.\\\\\nA label with an empty label value is considered equivalent to a label that does not exist.\\\\\n\\textbf{For example, a time series with the metric name api\\_http\\_requests\\_total and the labels method=\"POST\" and handler=\"messages\" could be written like this:\\\\\napi\\_http\\_requests\\_total\\{method=\"POST\", handler=\"messages\"\\}}\n\n\n\\subsection{Exposition Format}\nFor the http exposition, today metrics could be exposed with 2 ways.\n\\begin{itemize}\n\\item Text-format : first created way to expose metrics to Prometheus just via plain text lines \n\\item OpenMetrics : OpenMetrics want to indroduce some standardisation in the exposition of the metrics, still in developpment \n\\end{itemize}\n\\url{https://github.com/prometheus/docs/blob/main/content/docs/instrumenting/exposition_formats.md}\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n\\section{PromQL}\n\\subsection{Presentation of metric types}\n\\begin{itemize}\n\\item Counter : A counter is a cumulative metric that represents a single monotonically increasing counter whose value can only increase or be reset to zero on restart. For example, you can use a counter to represent the number of requests served, tasks completed, or errors.\\\\\nDo not use a counter to expose a value that can decrease. For example, do not use a counter for the number of currently running processes; instead use a gauge.\n\\item Gauge : \nA gauge is a metric that represents a single numerical value that can arbitrarily go up and down.\\\\\nGauges are typically used for measured values like temperatures or current memory usage, but also \"counts\" that can go up and down, like the number of concurrent requests.\n\\item Histogramm : A histogram samples observations (usually things like request durations or response sizes) and counts them in configurable buckets. It also provides a sum of all observed values.\n\\item Summary : Similar to a histogram, a summary samples observations (usually things like request durations and response sizes). While it also provides a total count of observations and a sum of all observed values, it calculates configurable quantiles over a sliding time window.\n\\end{itemize}\n\\url{https://prometheus.io/docs/concepts/metric_types/}\n\\subsection{Selecting Data}\n\\begin{center}\n\\includegraphics[scale=0.6]{prom_req.jpg}\n\\end{center}\n\\begin{itemize}\n\\item Instant vector :\n\\begin{center}\n\\includegraphics[scale=0.6]{instant_vect.jpg}\n\\end{center}\n\\item Range vector :\n\\begin{center}\n\\includegraphics[scale=0.6]{range_vect.jpg}\n\\end{center}\n\\end{itemize}\n\\url{https://satyanash.net/software/2021/01/04/understanding-prometheus-range-vectors.html}\n\\subsection{Rates and Derivatives}\n\\subsubsection{Rates}\nThe ``rate'' function of Prometheus use the ``variation rate'' formula that we know as below : \n\\begin{equation}\n(f(a+h)-f(a))/h\n\\end{equation}\nIt's using the range vector that we saw earlier, you can have an estimation about the metric ``x'' is evolving in the time. You can use it like this :\\\\\nrate[1m] = (count at 2m - count at 1m) / 60 = (4423 - 4381) / 60 = 0.7\\\\Rate could be usefull to saw how fast a metric is evolving but it's \\textbf{only available for counters}, not for gauges.\n\\subsubsection{Derivatives}\nDerivative, in monitoring, allow us to see how a metric is evolving per second. It's quite similar to rate but we will use derivative function with gauges metrics only.\n\\subsection{Aggregating over time}\nThis X\\_over\\_time(Y) function is usefull to compare multiple range vectors. It will compare range vectors on se same interval and returning an instant vector.\n\\begin{center}\n\\includegraphics[scale=0.6]{aggreg.jpg}\n\\end{center}\nOn the example below, we could imagine a series named temperature\\_instant with 2 different value of the label \\{instance\\}. \\{instance=''A''\\} and \\{instance=''B''\\} respectively blue and red colors. We want to know the average temperature (not just a simple delta between the first and last value) during a period of 5mn. By using avg\\_over\\_time(temperature\\_instant[5m]) we will get : \n\\begin{itemize}\n\\item temperature\\_instant\\{instance=''A''\\} : 45\n\\item temperature\\_instant\\{instance=''B''\\} : 15\n\\end{itemize}\n\\begin{center}\n\\includegraphics[scale=0.1]{example.jpg}\n\\end{center}\n\n\\url{https://iximiuz.com/en/posts/prometheus-functions-agg-over-time/}\n\\subsection{Aggregating over dimensions}\nThis section concern the aggregation operator. It's a serie of fonction that allows you to do some operations on a value of a metric. Thoose operators are \\textbf{only working with instant vectors}, not range vectors.\\\\Under this you can find a list of the aggregation operators privided by the official documentation :\n\\begin{itemize}\n\\item sum (calculate sum over dimensions)\n\\item min (select minimum over dimensions)\n\\item max (select maximum over dimensions)\n\\item avg (calculate the average over dimensions)\n\\item group (all values in the resulting vector are 1)\n\\item stddev (calculate population standard deviation over dimensions)\n\\item stdvar (calculate population standard variance over dimensions)\n\\item count (count number of elements in the vector)\n\\item count\\_values (count number of elements with the same value)\n\\item bottomk (smallest k elements by sample value)\n\\item topk (largest k elements by sample value)\n\\item quantile (calculate $\\phi$-quantile (0 $\\leq\\phi\\leq$ 1) over dimensions)\n\\end{itemize}\nWe can add words after the request like \\textbf{or, without} to sort the result with a label value like this :\\\\ \\textbf{<aggr-op> [without|by (<label list>)] ([parameter,] <vector expression>)\\\\\nor\\\\<aggr-op>([parameter,] <vector expression>) [without|by (<label list>)]}\n\\subsection{Binary operators}\nPrometheus's query language supports basic logical and arithmetic operators. For operations between two instant vectors, the matching behavior can be modified.\n\\subsubsection{Arithmetic binary operator}\nTo do some requests, Prometheus allows you to make some operations between scalar/scalar, vector/scalar, and vector/vector value pairs. Like bellow : \n\\begin{itemize}\n\\item $ +$\n\\item$ -$\n\\item $* $\n\\item $/ $\n\\item$ \\% $\n\\item \\url{^}\n\\end{itemize}\n\\subsubsection{Comparison binary operator}\n\\begin{itemize}\n\\item $ ==$\n\\item $ !=$\n\\item $ >$\n\\item $ <$\n\\item $ >=$\n\\item $<= $\n\\end{itemize}\n\\subsubsection{Logical binary operator}\n\\begin{itemize}\n\\item and (intersection)\n\\item or (union)\n\\item unless (complement)\n\\end{itemize}\n\\subsection{Histograms}\nHistogram is a specific type of metric, you can see bellow a two-dimension representation : \n\\begin{center}\n\\includegraphics[scale=0.5]{histo.jpg}\n\\end{center}\nPrometheus application of histograms is a little bit different than this example. \n\\begin{itemize}\n\\item Each bucket is cumulative, the value will always increase. The same example from a Prom view will give that :\n\\begin{center}\n\\includegraphics[scale=0.5]{histo_prom.jpg}\n\\end{center}\n\\item Histograms values are composed of buckets (blue rectangle on the picture). Each bucket is composed of different values count inferior or equal to the bucket value.\n\\item \n\\end{itemize}\n\\url{https://andykuszyk.github.io/2020-07-24-prometheus-histograms.html}\n\\url{https://medium.com/mercari-engineering/have-you-been-using-histogram-metrics-correctly-730c9547a7a9}\n\\subsection{Timestamp Metrics}\nTimestamp is a int64 number in millilsecond used to store and reference the metric in the TSDB. Each sample/value in Prometheus is stored with a value and a timestamp.\n\\url{https://prometheus.io/docs/concepts/data_model/}\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n\\section{Instrumentation and exporters}\n\\subsection{Client Libraries}\nBefore you can monitor your services, you need to add instrumentation to their code via one of the Prometheus client libraries. These implement the Prometheus metric types.\\\\Choose a Prometheus client library that matches the language in which your application is written. This lets you define and expose internal metrics via an HTTP endpoint on your application\8217s instance:\n\\begin{itemize}\n\\item Go\n\\item Java or Scala\n\\item Python\n\\item Ruby\n\\item Rust\n\\end{itemize}\n\\subsection{Instrumentation}\nInstrumentation is a best practice that advise you to make all of your applications exposing their own metrics. Like this, you could easily monitor your programms and have a look on the activities of your code.\\\\You can use the Prometheus libraries for the langage that you use.\n\\subsection{Exporters}\n\\subsubsection{Definition of exporters}\nExporter are little servers that will find and expose metrics on an http port. Prometheus will scrape the metrics expose by the exporter to put it in it's TSDB. It's usefull because if an exporter exist for the application or service that you want to minitor, you can quickly add this to your Prometheus supervision.\n\\subsubsection{Exporters from community}\nThere are some ``official'' exporters on the Github page of Prometheus. But not enougth for everything. So there is a lot of ``third-party'' exporters written by the community. Some can help you to monitor your systems.\\\\For example : \\url{https://github.com/arthur-ehrle/nsx-exporter} \n\\subsubsection{Making your own exporters}\nIf you have a new need for a Prometheus monitoring, you can write your Prometheus exporter by using the libaries that we mentionned before.\\\\You can refered to the best practives given by the Prometheus documentation \\url{https://prometheus.io/docs/instrumenting/writing_exporters/}\n\\subsection{Structuring and naming metrics}\nThere is some best pratices to follow when you create your own metrics. \\url{https://prometheus.io/docs/instrumenting/writing_exporters/#naming}\\\\\nGenerally metric names should allow someone who is familiar with Prometheus but not a particular system to make a good guess as to what a metric means. A metric named http\\_requests\\_total is not extremely useful - are these being measured as they come in, in some filter or when they get to the user\8217s code? And requests\\_total is even worse, what type of requests?\\\\\nWith direct instrumentation, a given metric should exist within exactly one file. Accordingly, within exporters and collectors, a metric should apply to exactly one subsystem and be named accordingly.\\\\\nMetric names should never be procedurally generated, except when writing a custom collector or exporter.\\\\\nMetric names for applications should generally be prefixed by the exporter name, e.g. haproxy\\_up.\n\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n\\section{Alerting and dashboarding}\n\\subsection{Dashboarding basics}\nDashboards acts as the presentation layer for a user. It's the graph that you will look frequently to get informations about a system. It has to be a developped and effective system. Prometheus is not able to be qualified as a data-visualisation tool. Of course, it has a web gui, but it's only usefull to test your PromQL queries. You should use a third-party tool like Grafana to visualize your data.\\\\There is some recommandations for the creation of your dashboards that you can find in the official documentation like :\n\\begin{itemize}\n\\item Have no more than 5 graphs on a console.\n\\item Have no more than 5 plots (lines) on each graph. You can get away with more if it is a stacked/area graph.\n\\item When using the provided console template examples, avoid more than 20-30 entries in the right-hand-side table.\n\\end{itemize}\n\\subsection{Configuring Alerting rules}\nAlerting with Prometheus is separated into two parts. Alerting rules in Prometheus servers send alerts to an Alertmanager. The Alertmanager then manages those alerts, including silencing, inhibition, aggregation and sending out notifications via methods such as email, on-call notification systems, and chat platforms.\\\\The main steps to setting up alerting and notifications are:\n\\begin{itemize}\n\\item Setup and configure the Alertmanager\n\\item Configure Prometheus to talk to the Alertmanager\n\\item Create alerting rules in Prometheus\n\\end{itemize}\nJust under, you can find a configuration example of the alert file from Prometheus.\n\\begin{center}\n\\includegraphics[scale=0.5]{alert_ex.jpg}\n\\end{center}\nPrometheus will have a lot of conditions to start a trigger, the expression has to be matched for a certain periode. To write the expression, you have to use PromQL. If time condition is OK, the state will come from ``pending'' to ``active'' and send a push request to Alertmanager with some informations, like all the ``label'' defined in the rule.\n\\subsection{Understand and Use Alertmanager}\nAlertmanager isn't the tool that will create alerts. We saw that this part was handled by Prometheus. Alertmanager is a notifier, it will received triggers and send notifications via some channels inluding informations. It was do that depending on the content of the label alerts that he received.\n\\begin{center}\n\\includegraphics[scale=0.5]{am_presentation.jpg}\n\\end{center}\nFor example you can define an alert in Prometheus with le label \\textbf{team: NOC-agents} and in Alertmanager you can say that the Alerts marked by \\textbf{team: NOC-agents} has to be forwarded to an API url to send SMS.\n\\subsection{Alerting basics (when, what, and why)}\nAn alarm is a piece of configuration describing a system\8217s change in state, most typically a highly undesirable one, through fluctuations of data points in a timeseries. Alarms are made up of metric monitors and date-time evaluations and may optionally nest other alarms.\\\\\nAn alert is a notification of a potential problem, which can take one or more of the following forms: email, SMS, phone call, or a ticket. An alert is issued by an alarm when the system transitions through some threshold, and this threshold breach is detected by a monitor. Thus, for example, you may configure an alarm to alert you when the system exceeds 80\\% of CPU utilization for a continuous period of 10 minutes.\\\\\nA metric monitor is attached to a timeseries and evaluates it against a threshold. The threshold consists of limits (expressed as the number of data points) and the duration of the breach. When the arriving data points fall below the threshold, exceed the threshold, or go outside the defined range for long enough, the threshold is said to be breached and the monitor transitions from clear into alert state. When the data points fall within the limits of the defined threshold, the monitor recovers and returns to clear state. Monitor states are used as factors in the evaluation of alarm states.\n\n\\end{document}"
